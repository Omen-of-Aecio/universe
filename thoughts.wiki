= Currently/TODO =
- LATEST: Client obviously does not see the bullets
    should send a message that a player has shot a bullet (include position maybe, for robustness)
    then update 

- Remove Bullet when outside of screen
- **no reliable way to see if standing on ground** (need for ground friction)

- Shooting: Bullet component
    - Carries an "explosive" - a routine to explode environment?
    - movement behaviour (actually just need an initial movement speed
        - maybe requires to generalize MoveSys (to not just be for players)
- Taking it further:
    - imagine a laser - not an object
    - give it (and other weapons) a certain degree of destruction
        - partial destruction of tiles? -> common air? Rather common ground.

- How to deal with player actions? Maybe through ECS? For example letting Player have an array of actions

- Integrate Color + Shape? YES

- Robust and adjustable granularity of sweeping in `tilenet`.
     - say a laser weapon... should absolutely sweep all tiles.
       maybe we need a method to sweep a certain diameter


= TileNet =
- solve: just return new Collable rather than mutate?
  - could alleviate e.g. having the result in RayCollable
- should maybe operate with only u32 altogether. Or i32 and always check bounds
- make solve() return the result rather than mutate? (??)

- Would be nice if the motion of Player and Bullet, etc, were just mere physics.
        But the player system would 

= Network =
- add timestamps, and try to keep in sync?
`https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking`
- general idea: on a listen server, could make it possible to visualize server vs. client hitboxes ETC
=== Entity Interpolation ===
- server has a tick rate, but clients receive packets at some other rate depending on BW
- delta compression in snapshots
- render back in time - **interpolate** between already-received snapshots
    - this lag is compensated for in the server
=== Input Prediction (Client) ===
    "the client runs exactly the same code and rules the server will use to process the user commands"
    - gradually correct errors over a period of time to hide prediction errors
=== Lag Compensation (Server) ===
When user command/input is received:
 1. Estimate `Command Execution Time = Current Server Time - Packet Latency - Client View Interpolation`
 2. Move all players back to that time (keeps track of history for last second)
 3. Move all players back

== Roadmap ==
1. Entity interpolation, snapshots, delta time
2. Input Preduction
3. Delta compression
(4. Lag Compensation)

== Snapshots ==
Easiest solution:
 - `full_snapshot`: includes Shape, Color ETC
 - `partial_snapshot`: only things that change such as Vel, Pos, etc
 - when a player joins or something else changes, we have to (manually) add to packet

*Easier solution:*
 - Compare _snapshots_. `Snapshot { entities: BTreeMap<Entity> }`, make `Component` a struct ETC for linear operation.
 - PROBLEM: Snapshot is not enough since it may exclude things, need to save entire state per client!!!
    - What about `Component (Option<Pos>,Option<Vel>, ...)`
              and ummmmm somehow setting the unwanted fields to None or the like just when sending.
              *need a switchable Option which takes space in memory but whose Serialization is optional*
 - PROBLEM: How to 


*Harder solution*
 - Change `specs` to give diffs (what changed)
 - PROBLEM: Different package rates than tick rate.
    -> History of diffs, sum up diffs needed. Only store what *frame* was last sent for each client.


= Rendering =
 - Render tilenet 
 - Render polygons (system)
 - Render lines

= Resources =
  - RenderConfig
  - GameConfig
  - TileNet
  - Display

  - `tilenet_ren::Ren`
  - `polygons::ren::Ren`


= Structure =
Client
  Networking
  Systems
  CliGame
    Components

Server
  SrvGame
    Components
  Systems



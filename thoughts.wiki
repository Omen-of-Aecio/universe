= Scratch / Current =
NOW: Change `net` so that we can see what has been ACKed... handles?
    - `net` idea: if we have one module for unreliable, and one for reliable messages.. way to stitch them together...
    - considering to just pass a closure to `net` for the event when something is ACKED
Closure problems:
    - just mutate local state that is wrapped in internal mutability
    - namely.. Mutex<Vec<SocketAddr>>

*Question*.... how do we *fully* represent the client's knowledge?  Packets can be lost!!!
    1) Ack every snapshot
            - more general, maybe more future proof *Select*
    3) ALWAYS send pos UNRELIABLY
       ONLY ON CHANGE send shape, color - and do so RELIABLY
       Levels? INIT, CHANGE, ALWAYS

- Need one diff every frame  - just store the BitSets.
- Procedure to create Snapshot from a certain tick in time, adding these diffs together.
    -- Components start with all `None`, ...
- `Components` can use Option rather than SerOption



PROBLEM with Snapshots: need to be reliable to be able to send changes!!
    - better yet, with ACK but without resend.
      - If no ACK for a while then MERGE the un-acked Snapshot with what will be sent.
 -> NEED CHANGE IN `net`... Maybe a rewrite?

* DELETING ENTITITES (registering a deletion on Server)
   - delta compression can handle that





= TODO =
- Note: * input * messages * world.maintain * update *
    
- **no reliable way to see if standing on ground** (need for ground friction)
    
- Remove Bullet when outside of screen

- Bullet:
    - imagine a laser - not an object
    - give it (and other weapons) a certain degree of destruction
        - partial destruction of tiles? -> common air? Rather common ground.

- How to deal with player actions? Maybe through ECS? For example letting Player have an array of actions

- Generalize MoveSys



= Optimizations =
- Integrate Color + Shape? YES

- while we can serialize the Snapshot...
    Is it possible to do apply it *while* deserializing? LATER. OPTIMIZATION.
    
- Robust and adjustable granularity of sweeping in `tilenet`.
     - say a laser weapon... should absolutely sweep all tiles.
       maybe we need a method to sweep a certain diameter

= TileNet =
- solve: just return new Collable rather than mutate?
  - could alleviate e.g. having the result in RayCollable
- should maybe operate with only u32 altogether. Or i32 and always check bounds
- make solve() return the result rather than mutate? (??)

- Would be nice if the motion of Player and Bullet, etc, were just mere physics.
        But the player system would 

= Network =
- add timestamps, and try to keep in sync?
`https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking`
- general idea: on a listen server, could make it possible to visualize server vs. client hitboxes ETC
=== Entity Interpolation ===
- server has a tick rate, but clients receive packets at some other rate depending on BW
- delta compression in snapshots
- render back in time - **interpolate** between already-received snapshots
    - this lag is compensated for in the server
=== Input Prediction (Client) ===
    "the client runs exactly the same code and rules the server will use to process the user commands"
    - gradually correct errors over a period of time to hide prediction errors
=== Lag Compensation (Server) ===
When user command/input is received:
 1. Estimate `Command Execution Time = Current Server Time - Packet Latency - Client View Interpolation`
 2. Move all players back to that time (keeps track of history for last second)
 3. Move all players back

== Roadmap ==
1. Entity interpolation, ~~snapshots~~, ~~delta time~~
2. Delta compression
3. Input Preduction
(4. Lag Compensation)


= Fragmentation & partial Snapshots (partition entities) =
* How to avoid big packets.. Should be maximum about 1 KB.
    1) ~~Fragment at Packet.~~
    2) Fragment into groups of Entities before sending.
    3) Client specifies what percentage of state it wants every frame. 1.0 is too much.
            and e.g. 0.5 means during 2 frames all state will be sent. Server will keep
            track of the progress from frame to frame. Might need to look at Snapshot
            then.
        Cons: Client needs to interpolate components/entities individually. Maybe "shadow" components
              that manifests this interpolation?
              
* Idea: bin packing entities
    - need ACK but not resend on each packet (to know the state that the client has)

 - `net::Connection::estimate_rtt()`: estimate RRT based on reliable packets
 - `net::Connection::is_acked(seq) -> bool` --- use to see if we need to resend
        - but DISABLE AUTOMATIC RESEND
 - Store last sent Snapshot and "Snapshot in progress" together with the progress?
    - partition entities or bytes?
    - or simplify by sending entire Snapshot in a second?
    - 

= Rendering =
 - Render tilenet 
 - Render polygons (system)
 - Render lines

= Resources =
  - RenderConfig
  - GameConfig
  - TileNet
  - Display

  - `tilenet_ren::Ren`
  - `polygons::ren::Ren`


= Structure =
Client
  Networking
  Systems
  CliGame
    Components

Server
  SrvGame
    Components
  Systems


